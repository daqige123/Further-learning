### 函数
#### 在哪里调用这个函数，就是把这个函数里面的代码放在哪里执行，然后代码就在当前的上下文中找对应的变量，找不到就往上一级的上下文中去找，知道window里也找不到再报错。

####  箭头函数

##### 为什么使用箭头函数

箭头函数比较简洁，比较适合嵌入函数的场景。

#### 箭头函数的特点

1. 不能使用argument, super, new.target
2. 不能用做构造函数，没有prototype属性。
3. 箭头函数没有自己的this, 是在定义的时候继承外部函数的this。不会随着执行上下文的变化而改变。

#### 函数声明和函数表达式的区别

唯一区别就是函数声明提升: 就是函数声明会在任何代码执行之前被读取，并添加到执行上下文。

#### 函数的内部

#### this对象， arguments对象，new.target属性， caller

arguments里面还有一个callee ，callee指向arguments对象所在的函数。比如可以用在取消递归函数的名字与函数本身的依赖。 caller指向待用当前函数的函数，如果在是在全局中调用的，就是null了。

new.target用来判断是否是用new来调用的，也就是判断他是不是被当作构造函数调用的。

#### this

##### 1. 在标准函数中的this引用的是把函数当作方法调用的上下文对象。我们判断this到底指向哪儿的时候必须要等他调用的时候才能确定。

2.在默认情况(非严格模式下,未使用 'use strict'),没找到直接调用者,则this指的是 window (约定俗成)

3.在严格模式下,没有直接调用者的函数中的this是 undefined

4.使用call,apply,bind(ES5新增)绑定的,this指的是 绑定的对象

##### 

##### 在箭头函数中，this引用的是定义箭头函数的上下文。

#### 函数是对象

所有每个函数都有prototype属性， 函数还有length属性，保存函数定义的命名参数的个数。

#### apply、call

##### 因为函数就是在不同执行上下文中执行的一段代码，所以我们可以使用apply，call来改变这些代码的执行上下文。

call是一个个的传，apply是一个数组。



#### 2.1 作用域终极版理解

##### 执行上下文：

​       一个函数被调用时，js就会给它创建一个执行上下文（每一个上下文都关联着一个变量对象（这个对象存储着该上下文中定义的所有变量和函数））。

​        补充：上下文分为全局上下文（window对象）和函数上下文。函数的每次执行都会创建的执行上下文都是独一无二。因为当函数执行完毕时，他产生的上下文就会被销毁，包括函数上下文中定义的变量和函数。

##### 作用域链：

​      上下文中的代码在执行时，会创建一个作用域链，这个作用域链就是，里面存储了函数执行时的上下文关联的变量对象和他父级的变量对象。

##### ![img](file://C:\Users\24026\AppData\Roaming\Typora\typora-user-images\image-20210430095933530.png?lastModify=1623395447)

猜测 ：其实这里的this 应该就是指向的一个上下文对应的变量对象。

定义： 在标准函数中this引用的是把函数当成方法调用的上下文对象。

##### 注：什么时候会出现this呢？

#####  其实是每个函数在别调用时都会创建一个this，arguments变量，正常函数声明中，this是指向这个函数所处的执行上下文变量对象；还有就是出现在对象的方法中调用时，this等于这个对象。所以当我们判断this的时候，就看这行代码执行时，这个this指的时哪一个变量对象（活动对象，或者对象）。



#### 2.2 闭包   https://zhuanlan.zhihu.com/p/22486908

```js
		function sum() {
            let n = 1;
            return function () {
                console.log(++n);
            }
		}
		sum() // 2
		sum() // 2
       
		let a = sum();  
        a(); //  2   
        a();  // 3
        a();  // 4
// 这里是因为sum（）被存进了a, a又是全局变量，不会被垃圾回收，
// 下次调用a()的时候，a的值会在内存中保存，所以这就是再原有基础上加1的原因。
```



定义： 闭包是指那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的，return 一个函数，是为了使用内部的嵌套函数。

##### 闭包是js函数作用域的副产品，因为JS的函数内部可以使用外部的变量，所以这本来就符合了闭包的定义。

##### 闭包的作用：

#####    1.延长外部函数的局部变量的生命周期，可以实现计数器、累加器这种。

​       为什么？： 因为 a = sum()， 把函数保存在a中，a又是全局变量，不会被垃圾回收，a的值会在内存中被保存，也就是a里面的num也会被保存 ，然后下次调用a的时候，a里面的num就实现的累加，

#####    2.  私有（隐藏）变量（间接访问一个变量）

​         如果直接申明一个全局变量的话，那么很容易被误修改，因为无论哪里的代码都能通过作用域链         来操作全局变量（window永远处于作用域链的最顶层）。

​        但是如果把他变成一个函数里的局部变量，再通过返回一个函数（访问器），来让别人访问和操   作，就保险多了。

#### 重点：闭包题总结 

总结， 这个闭包的题其实就是在先调用外部函数，把作用域链创建出来，

 然后通过将返回的闭包函数复制给一个变量（可以是return 返回给一个全局变量， 也可以是下面的 直接 fn= 闭包函数），这样由于外部的变量没有被销毁，作用域链得以保存。



#### 立即调用表达式

```js
(function(){ code }) ()   ====》 {code}
```

感觉就是用来解决es6以前没有块级函数作用域的问题，使用这个立即调用就能将函数里面的代码作用域限制在这个匿名函数里面。

